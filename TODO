#TODO fix save/load
      empêcher save load de modifier la valeur de joueur courant pour autre chose qu'un objet joueur
      empêcher save load de s'exécuter si on fait une nouvelle partie

#TODO Faire les docstrings
      enlever les instructions du prof et juste laisser la définition, args et return
      
#TODO Changer dictionnaire pour liste
      L'AI sera dans lister_coups_possibles ou dans une nouvelle méthode que j'ajoute à la suite
      si le joueur courant est un computer
      
#TODO transférer AI dans lister_coups_possibles si joueur_courant == computer
      POUR L'AI la stratégie sera, dans cet ordre:
      1- joue coins si coins possibles
      2- priorise les cases à 2 cases des coins, en lignes droite
      3- priorise les cases à 2 cases des coins, en diagonale
      4- priorise les coups qui ne permettent pas à l'adversaire de jouer un coin
      5- priorise les coups qui ne permettent pas à l'adversaire de joueer à 2 cases des coins, en lignes droite
      6- priorise les coups qui ne permettent pas à l'adversaire de jouer à 2 cases des coins, en diagonale
      7- priorise les coups qui mangent le plus de pièces
      8- priorise parmis ce qui reste, ceux qui limitent le plus possible le nombre de pièces maximum mangées par l'adversaire
      9- si plusieurs coups sont égaux, choisis au hasard parmi ceux-ci
      
      

#TODO nettoyer redondance validation
  
      VALIDATION EXPLICATION DU PROF:
      Le processus de validation est le suivant :
  
      Dans Partie.tour():
      On fait appel à Partie.valider_position_coup() qui va faire 3
      différentes validations (coup hors de la planche, coup déjà joué ou coup s
      ans prise) et retourner un message correspondant.
      Une validation supplémentaire sur le résultat planche.jouer_coup().
      Ici, au final, cette validation n'est pas totalement nécessaire avec l'état
      actuel du programme, car on vient juste faire appel à self.coup_est_
      possible(), qui a déjà été appelé en fait. Par contre, c'est principalement
      une validation qui permet de se "blinder" sur une éventuelle erreur non
      prévue.
  


